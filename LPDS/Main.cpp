#include "Main.h"
#include "opencv2/imgcodecs.hpp"
#include "opencv2/imgproc.hpp"
#include "opencv2/videoio.hpp"
#include <opencv2/highgui.hpp>
#include <opencv2/video.hpp>
#include <stdio.h>
#include <iostream>
#include <sstream>
#include <string>
#include <vector>
#include <fstream>
#include <windows.h>
#include <stdio.h>
#include <time.h>
#include <fstream>
#include <time.h>
#include <ctime>
#include <cstdio>
using namespace cv;
using namespace std;

//default capture width and height
const int FRAME_WIDTH = 640;
const int FRAME_HEIGHT = 480;
//max number of objects to be detected in frame
const int MAX_NUM_OBJECTS = 500;
//minimum and maximum object area // camera 1
const int MIN_OBJECT_AREA = 380*250;
const int MAX_OBJECT_AREA = 440*330;

//minimum and maximum object area // camera 2
const int MIN_OBJECT_AREA2 = 380*200;
const int MAX_OBJECT_AREA2= 505*300;

Mat frame;   // camera 1
Mat MOG21; //fg mask fg mask generated by MOG21 method
Ptr<BackgroundSubtractor> pMOG21; //MOG21 Background subtractor

Mat frame1;  // camera 2
Mat MOG22; 
Ptr<BackgroundSubtractor> pMOG22; 

int keyboard; //input from keyboard

void wait(int seconds){
	clock_t endwait;
	endwait = clock() + seconds*CLOCKS_PER_SEC;
	while (clock()<endwait);
}


void waitf(float seconds){
	clock_t endwait;
	endwait = clock() + int(seconds*float(CLOCKS_PER_SEC));
	while (clock()<endwait);
}

void morphOps(Mat &thresh){

	//create structuring element that will be used to "dilate" and "erode" image.
	//the element chosen here is a 3px by 3px rectangle

	Mat erodeElement = getStructuringElement(MORPH_RECT, Size(3, 3));
	//dilate with larger element so make sure object is nicely visible
	Mat dilateElement = getStructuringElement(MORPH_RECT, Size(8, 8));

	erode(thresh, thresh, erodeElement);
	erode(thresh, thresh, erodeElement);


	dilate(thresh, thresh, dilateElement);
	dilate(thresh, thresh, dilateElement);



}

/**
* Helper function to find a cosine of angle between vectors
* from pt0->pt1 and pt0->pt2
*/
static double angle(cv::Point pt1, cv::Point pt2, cv::Point pt0)
{
	double dx1 = pt1.x - pt0.x;
	double dy1 = pt1.y - pt0.y;
	double dx2 = pt2.x - pt0.x;
	double dy2 = pt2.y - pt0.y;
	return (dx1*dx2 + dy1*dy2) / sqrt((dx1*dx1 + dy1*dy1)*(dx2*dx2 + dy2*dy2) + 1e-10);
}


/**
* Helper function to display text in the center of a contour
*/
void setLabel(cv::Mat& im, const std::string label, std::vector<cv::Point>& contour)
{
	int fontface = cv::FONT_HERSHEY_SIMPLEX;
	double scale = 0.4;
	int thickness = 1;
	int baseline = 0;

	cv::Size text = cv::getTextSize(label, fontface, scale, thickness, &baseline);
	cv::Rect r = cv::boundingRect(contour);

	cv::Point pt(r.x + ((r.width - text.width) / 2), r.y + ((r.height + text.height) / 2));
	cv::rectangle(im, pt + cv::Point(0, baseline), pt + cv::Point(text.width, -text.height), CV_RGB(255, 255, 255), CV_FILLED);
	cv::putText(im, label, pt, fontface, scale, CV_RGB(0, 0, 0), thickness, 8);
}

string intToString(int number){


	std::stringstream ss;
	ss << number;
	return ss.str();
}

void drawObject(int x, int y, Mat &frame){

	//use some of the openCV drawing functions to draw crosshairs
	//on your tracked image!
	//memory errors from writing off the screen (ie. (-25,-25) is not within the window!)

	circle(frame, Point(x, y), 20, Scalar(0, 255, 0), 2);
	if (y - 25 > 0)
		line(frame, Point(x, y), Point(x, y - 25), Scalar(0, 255, 0), 2);
	else line(frame, Point(x, y), Point(x, 0), Scalar(0, 255, 0), 2);
	if (y + 25 < FRAME_HEIGHT)
		line(frame, Point(x, y), Point(x, y + 25), Scalar(0, 255, 0), 2);
		
	else line(frame, Point(x, y), Point(x, FRAME_HEIGHT), Scalar(0, 255, 0), 2);
	if (x - 25 > 0)
		line(frame, Point(x, y), Point(x - 25, y), Scalar(0, 255, 0), 2);
	else line(frame, Point(x, y), Point(0, y), Scalar(0, 255, 0), 2);
	if (x + 25 < FRAME_WIDTH)
		line(frame, Point(x, y), Point(x + 25, y), Scalar(0, 255, 0), 2);
	else line(frame, Point(x, y), Point(FRAME_WIDTH, y), Scalar(0, 255, 0), 2);

	putText(frame, intToString(x) + "," + intToString(y), Point(x, y + 30), 1, 1, Scalar(0, 255, 0), 2);

}


bool trackFilteredObject(int &x, int &y, Mat threshold, Mat &cameraFeed){ // for camera 1

	Mat temp;
	threshold.copyTo(temp);
	//these two vectors needed for output of findContours
	vector< vector<Point> > contours;
	vector<Vec4i> hierarchy;
	//find contours of filtered image using openCV findContours function
	findContours(temp, contours, hierarchy, CV_RETR_CCOMP, CV_CHAIN_APPROX_SIMPLE);
	//use moments method to find our filtered object
	double refArea = 0;
	bool objectFound = false;
	if (hierarchy.size() > 0) {
		int numObjects = hierarchy.size();
		//if number of objects greater than MAX_NUM_OBJECTS we have a noisy filter
		if (numObjects < MAX_NUM_OBJECTS){
			for (int index = 0; index >= 0; index = hierarchy[index][0]) {

				Moments moment = moments((cv::Mat)contours[index]);
				double area = moment.m00;

				//if the area is less than 20 px by 20px then it is probably just noise
				//if the area is the same as the 3/2 of the image size, probably just a bad filter
				//we only want the object with the largest area so we safe a reference area each
				//iteration and compare it to the area in the next iteration.
				if (area > MIN_OBJECT_AREA && area<MAX_OBJECT_AREA && area>refArea){
					x = moment.m10 / area;
					y = moment.m01 / area;
					objectFound = true;
					refArea = area;
					putText(cameraFeed, "Tracking Object", Point(0, 50), 2, 1, Scalar(0, 255, 0), 2);
					//draw object location on screen
					drawObject(x, y, cameraFeed);
					return true;

				}
				else{
					objectFound = false;
				}

			}
		
		}
		
	}
	
} 




String inttostr(int input)
{
	stringstream ss;
	ss << input;
	return ss.str();
}
int main(void) {

	bool blnKNNTrainingSuccessful = loadKNNDataAndTrainKNN();           // attempt KNN training

	if (blnKNNTrainingSuccessful == false) {                            // if KNN training was not successful
		// show error message
		std::cout << std::endl << std::endl << "error: error: KNN traning was not successful" << std::endl << std::endl;
		return(0);                                                      // and exit program
	}

	bool trackObjects = true;
	vector<int> compression_params; //vector that stores the compression parameters of the image
	compression_params.push_back(CV_IMWRITE_JPEG_QUALITY); //specify the compression technique
	compression_params.push_back(100); //specify the compression quality
	Mat threshold;
	cv::Mat src;
	cv::Mat gray;
	cv::Mat bw;
	cv::Mat dst;
    //x and y values for the location of the object
	int x = 0, y = 0;
	int x1 = 0, y1 = 0;
	int prevx = 300;
	int correct = 0;
	int wrong = 0;
	int tempx = 0;
	int cwait = 0;

	
	pMOG21 = createBackgroundSubtractorMOG2(); //camera 1
	pMOG22 = createBackgroundSubtractorMOG2(); //camera 2


	VideoCapture cap(1);
	cap.set(CV_CAP_PROP_FRAME_WIDTH, FRAME_WIDTH);
	cap.set(CV_CAP_PROP_FRAME_HEIGHT, FRAME_HEIGHT);


	VideoCapture cap1(2);
	cap1.set(CV_CAP_PROP_FRAME_WIDTH, FRAME_WIDTH);
	cap1.set(CV_CAP_PROP_FRAME_HEIGHT, FRAME_HEIGHT);

	
	
	Mat frame;
	Mat frame1;
	
	bool found = false;
	bool loop = false;
	int photocount = 0;
	String imagename;
	String imagename1;
	
	int a[40], b[40];
	string c[40], d[40];
	string s1, s2, s3;
	const String quote = "\"";
	// current date/time based on current system
	time_t now = time(0);

	// convert now to string form
	char* dt = ctime(&now);

	while ((char)keyboard != 'q' && (char)keyboard != 27){

		ofstream fout;
		fout.open("excel.csv", ios::out | ios::ate | ios::app);

		if ((!cap.read(frame) && !cap1.read(frame1)) || !cap.read(frame) || !cap1.read(frame1)) {
			cerr << "Unable to read next frame." << endl;
			cerr << "Exiting..." << endl;
			exit(EXIT_FAILURE);
		}
		
		if (x < tempx){
			tempx = x;
			correct++;
		}
		else if (x > tempx){
			tempx = x;
			wrong++;
	
		}
		else if (x == tempx){
			cwait = tempx;
		}

		else if (cwait != 0 && x < 20){
			cwait = 0;

		}
		else if (cwait != 0 && x > 600){
			cwait = 0;
		}
		// the value like 190 or 230 is depend on how you set the camera
		if (x >190 && x < 230){
			if (correct > wrong){
				std::cout << std::endl << " -------Correct lane------- : " << tempx << std::endl;
				x = 0;
				correct = 0;
				wrong = 0;
			}
			
		}
		if (x > 250 && x < 259){
			if (correct < wrong){
				std::cout << std::endl << " -------Wrong lane------- : " << tempx << std::endl;
				//////////////////////////////////////////////Capture at the front//////////////////////////////////////////////
				
				imagename = "D:/CarPic/front- " + inttostr(photocount) + ".jpg";//finalize imagename to save 
				imwrite(imagename, frame, compression_params);
				//////////////////////////////////////////////Capture at the back//////////////////////////////////////////////
				//imshow("Captured1", frame1);
				imagename1 = "D:/CarPic/back- " + inttostr(photocount) + ".jpg";//finalize imagename to save 
				imwrite(imagename1, frame1, compression_params);
				//////////////////////////////////////////////Save link and reason in excel file///////////////////////////////
			
				for (int i = 1; i < 5; i++)
				{


					if (i == 1){

						c[i] = "=HYPERLINK(" + quote + imagename + quote + ")";

					}
					if (i == 2){
						c[i] = "=HYPERLINK(" + quote + imagename1 + quote + ")";
					}

					if (i == 3){
						c[i] = dt;
					}
					if (i == 4){
						c[i] = "Driving in wrong lane";
					}
					fout << c[i] << ",";

					if (i == 4)


						fout << "\n";
				}

				ifstream fin("excel.csv");
				for (int i = 0; i < 40; i++)
				{
					fin >> b[i];

				}
				fout.close();
				x = 0;
				correct = 0;
				wrong = 0;
			}
			
			x = 0;
			correct = 0;
			wrong = 0;
			
		}
		
		//update the background model
		pMOG21->apply(frame, MOG21);
		pMOG22->apply(frame1, MOG22);
		//get the frame number and write it on the current frame
		morphOps(MOG21); // camera 1
		morphOps(MOG22); // cam
		//show the current frame and the fg masks
		if (trackObjects){

			if (trackFilteredObject(x, y, MOG21, frame) == true && trackFilteredObject(x1, y1, MOG22, frame1) == true)  {
		
				found = false;
				
				while (found != true)
				{
					cap >> frame;
					cap1 >> frame1;

					if ((frame.empty() && frame1.empty()) || frame.empty() || frame1.empty()) { 
						std::cout << "error: image not read from file\n\n";     
						return(0);                                              
					}


					std::vector<PossiblePlate> vectorOfPossiblePlates = detectPlatesInScene(frame);          

					vectorOfPossiblePlates = detectCharsInPlates(vectorOfPossiblePlates);                              

					std::vector<PossiblePlate> vectorOfPossiblePlates1 = detectPlatesInScene(frame1);         

					vectorOfPossiblePlates1 = detectCharsInPlates(vectorOfPossiblePlates1);                             

					if (vectorOfPossiblePlates.empty() && vectorOfPossiblePlates1.empty()) {   
				
						
						std::cout << std::endl << "no license plates on both side were detected" << std::endl;      
						found = true;

						//imshow("Captured", frame);
						imagename = "D:/CarPic/front- " + inttostr(photocount) + ".jpg";
						imwrite(imagename, frame, compression_params);


						imagename1 = "D:/CarPic/back- " + inttostr(photocount) + ".jpg";
						imwrite(imagename1, frame1, compression_params);

						for (int i = 1; i < 5; i++)
						{
							if (i == 1){

								c[i] = "=HYPERLINK(" + quote + imagename + quote + ")";

							}
							if (i == 2){
								c[i] = "=HYPERLINK(" + quote + imagename1 + quote + ")";
							}

							if (i == 3){
								c[i] = dt;
							}
							if (i == 4){
								c[i] = "No license plates on both side were detected";
							}
							fout << c[i] << ",";

							if (i == 4)


							fout << "\n";
						}

						ifstream fin("excel.csv");
						for (int i = 0; i < 40; i++)
						{
							fin >> b[i];

						}
						fout.close();
						
					}
					else if (vectorOfPossiblePlates.empty()){
					
						std::cout << std::endl << "no license plates on front side were detected" << std::endl;      
						found = true;
						imagename = "D:/CarPic/front- " + inttostr(photocount) + ".jpg";
						imwrite(imagename, frame, compression_params);

						imagename1 = "D:/CarPic/back- " + inttostr(photocount) + ".jpg"; 
						imwrite(imagename1, frame1, compression_params);

						for (int i = 1; i < 5; i++)
						{
							if (i == 1){

								c[i] = "=HYPERLINK(" + quote + imagename + quote + ")";

							}
							if (i == 2){
								c[i] = "=HYPERLINK(" + quote + imagename1 + quote + ")";
							}

							if (i == 3){
								c[i] = dt;
							}
							if (i == 4){
								c[i] = "No license plates on front side were detected";
							}
							fout << c[i] << ",";

							if (i == 4)


								fout << "\n";
						}

						ifstream fin("excel.csv");
						for (int i = 0; i < 40; i++)
						{
							fin >> b[i];

						}
						fout.close();
					}
					else if (vectorOfPossiblePlates1.empty()){
						
						std::cout << std::endl << "no license plates on back side were detected" << std::endl;       // inform user no plates were found
						found = true;
						imagename = "D:/CarPic/front- " + inttostr(photocount) + ".jpg";
						imwrite(imagename, frame, compression_params);

						imagename1 = "D:/CarPic/back- " + inttostr(photocount) + ".jpg";
						imwrite(imagename1, frame1, compression_params);

						for (int i = 1; i < 5; i++)
						{

							if (i % 4 == 1){

								c[i] = "=HYPERLINK(" + quote + imagename + quote + ")";

							}
							if (i % 4 == 2){
								c[i] = "=HYPERLINK(" + quote + imagename1 + quote + ")";
							}

							if (i % 4 == 3){
								c[i] = dt;
							}
							if (i % 4 == 0){
								c[i] = "No license plates on back side were detected";
							}
							fout << c[i] << ",";

							if (i % 4 == 0)


								fout << "\n";
						}

						ifstream fin("excel.csv");
						for (int i = 0; i < 40; i++)
						{
							fin >> b[i];

						}
						fout.close();
						
					}
					else {                                                                           
						
						std::sort(vectorOfPossiblePlates.begin(), vectorOfPossiblePlates.end(), PossiblePlate::sortDescendingByNumberOfChars);

					
						PossiblePlate licPlate = vectorOfPossiblePlates.front();

					

						if (licPlate.strChars.length() == 0) {                                                      
							std::cout << std::endl << "no characters were detected" << std::endl << std::endl;      
							found = true;                                                                              

							imagename = "D:/CarPic/front- " + inttostr(photocount) + ".jpg";
							imwrite(imagename, frame, compression_params);
							
						
							imagename1 = "D:/CarPic/back- " + inttostr(photocount) + ".jpg";
							imwrite(imagename1, frame1, compression_params);
			
							for (int i = 1; i < 5; i++)
							{

								if (i % 4 == 1){

									c[i] = "=HYPERLINK(" + quote + imagename + quote + ")";

								}
								if (i % 4 == 2){
									c[i] = "=HYPERLINK(" + quote + imagename1 + quote + ")";
								}

								if (i % 4 == 3){
									c[i] = dt;
								}
								if (i % 4 == 0){
									c[i] = "No characters on license plate were detected";
								}
								fout << c[i] << ",";

								if (i % 4 == 0)


									fout << "\n";
							}

							ifstream fin("excel.csv");
							for (int i = 0; i < 40; i++)
							{
								fin >> b[i];

							}
							fout.close();
						}
						else{
							found = true;

								

							std::cout << std::endl << "Found license plate" << std::endl << std::endl;
							wait(0.5);
						}


						drawRedRectangleAroundPlate(frame, licPlate);      // draw red rectangle around plate

						std::cout << std::endl << "license plate read from image = " << licPlate.strChars << std::endl;     // write license plate text to std out
						std::cout << std::endl << "-----------------------------------------" << std::endl;



					
					}

					
					

				}
			
				
			}

		}
		
		cv::imshow("Frame", frame);
		cv::imshow("Frame1", frame1);

		found = false;
		keyboard = waitKey(30);
		photocount++;
	}
	
	cap.release();

}

void drawRedRectangleAroundPlate(cv::Mat &imgOriginalScene, PossiblePlate &licPlate) {
	cv::Point2f p2fRectPoints[4];

	licPlate.rrLocationOfPlateInScene.points(p2fRectPoints);            // get 4 vertices of rotated rect

	for (int i = 0; i < 4; i++) {                                       // draw 4 red lines
		cv::line(imgOriginalScene, p2fRectPoints[i], p2fRectPoints[(i + 1) % 4], SCALAR_RED, 2);
	}
}


void writeLicensePlateCharsOnImage(cv::Mat &imgOriginalScene, PossiblePlate &licPlate) {
	cv::Point ptCenterOfTextArea;                   // this will be the center of the area the text will be written to
	cv::Point ptLowerLeftTextOrigin;                // this will be the bottom left of the area that the text will be written to

	int intFontFace = CV_FONT_HERSHEY_SIMPLEX;                              // choose a plain jane font
	double dblFontScale = (double)licPlate.imgPlate.rows / 30.0;            // base font scale on height of plate area
	int intFontThickness = (int)std::round(dblFontScale * 1.5);             // base font thickness on font scale
	int intBaseline = 0;

	cv::Size textSize = cv::getTextSize(licPlate.strChars, intFontFace, dblFontScale, intFontThickness, &intBaseline);      // call getTextSize

	ptCenterOfTextArea.x = (int)licPlate.rrLocationOfPlateInScene.center.x;         // the horizontal location of the text area is the same as the plate

	if (licPlate.rrLocationOfPlateInScene.center.y < (imgOriginalScene.rows * 0.75)) {      // if the license plate is in the upper 3/4 of the image
		// write the chars in below the plate
		ptCenterOfTextArea.y = (int)std::round(licPlate.rrLocationOfPlateInScene.center.y) + (int)std::round((double)licPlate.imgPlate.rows * 1.6);
	}
	else {                                                                                // else if the license plate is in the lower 1/4 of the image
		// write the chars in above the plate
		ptCenterOfTextArea.y = (int)std::round(licPlate.rrLocationOfPlateInScene.center.y) - (int)std::round((double)licPlate.imgPlate.rows * 1.6);
	}

	ptLowerLeftTextOrigin.x = (int)(ptCenterOfTextArea.x - (textSize.width / 2));           // calculate the lower left origin of the text area
	ptLowerLeftTextOrigin.y = (int)(ptCenterOfTextArea.y + (textSize.height / 2));          // based on the text area center, width, and height

	// write the text on the image
	cv::putText(imgOriginalScene, licPlate.strChars, ptLowerLeftTextOrigin, intFontFace, dblFontScale, SCALAR_YELLOW, intFontThickness);
}

